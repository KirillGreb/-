2. Объяснение кода
# -*- coding: utf-8 -*-: Это строка указывает кодировку исходного файла. UTF-8 - это кодировка, которая позволяет представлять символы из разных языков, включая русский.
import numpy as np: Импортирует библиотеку NumPy, которая предоставляет мощные инструменты для работы с массивами и матрицами. Здесь NumPy используется для представления матриц, векторов и выполнения матричных операций, что необходимо для фильтра Калмана. NumPy импортируется под псевдонимом np для удобства.
import matplotlib.pyplot as plt: Импортирует библиотеку Matplotlib, которая используется для построения графиков. Здесь она нужна для визуализации исходных и отфильтрованных данных. Matplotlib импортируется под псевдонимом plt для удобства.
process_noise = 0.01: Определяет стандартное отклонение гауссовского шума, который влияет на процесс движения объекта (например, на его скорость). Чем больше значение, тем более шумными будут изменения скорости.
measurement_noise = 0.1: Определяет стандартное отклонение гауссовского шума, который влияет на измерения положения. Чем больше значение, тем более зашумленными будут измерения положения.
dt = 1.0: Определяет временной шаг (интервал времени) между последовательными измерениями.
A = np.array([[1, dt], [0, 1]]): Матрица перехода состояния. Эта матрица определяет, как состояние (положение и скорость) объекта переходит из одного временного шага в другой. Она предполагает, что положение меняется на dt * скорость, а скорость остается постоянной.
B = np.array([[0.5 * dt**2], [dt]]): Матрица управления. В данном коде не используется для конкретной фильтрации, но она является частью стандартной модели фильтра Калмана.
H = np.array([[1, 0]]): Матрица измерения. Она связывает состояние (положение и скорость) с измерением. В этом случае, измерение - это только положение, поэтому H выбирает первое значение из вектора состояния.
Q = np.array([[process_noise**2, 0], [0, process_noise**2]]): Ковариационная матрица шума процесса. Она описывает, насколько сильно может меняться состояние от шага к шагу из-за шума процесса.
R = np.array([[measurement_noise**2]]): Ковариационная матрица шума измерений. Она описывает, насколько шумными являются измерения положения.
x = np.array([[0], [0]]): Начальное состояние фильтра Калмана, представляющее собой вектор с двумя элементами: начальное положение и начальная скорость. Оба значения инициализируются нулем.
P = np.eye(2): Начальная ковариационная матрица ошибки. Она показывает неопределенность начальной оценки состояния. np.eye(2) создает единичную матрицу 2x2, что означает, что начальные оценки положения и скорости независимы и имеют некоторую неопределенность.
num_samples = 100: Определяет количество временных шагов (измерений), которые будут имитированы.
true_position = np.linspace(0, 10, num_samples): Создает массив из 100 равномерно распределенных значений, представляющих “истинное” положение объекта от 0 до 10. Это просто прямая линия.
true_velocity = np.ones(num_samples) * 0.1: Создает массив из 100 элементов, каждый из которых равен 0.1. Это представляет собой “истинную” скорость объекта, которая постоянна, имитируя линейный дрейф.
measured_position = true_position + np.random.normal(0, measurement_noise, num_samples): Создаёт массив зашумленных измерений положения, добавляя гауссовский шум к истинному положению.
np.random.normal(0, measurement_noise, num_samples): Генерирует массив случайных чисел с гауссовским распределением со средним значением 0 и стандартным отклонением measurement_noise.
measured_velocity = true_velocity + np.random.normal(0, process_noise, num_samples): Создаёт массив зашумленных измерений скорости, добавляя гауссовский шум к истинной скорости.
np.random.normal(0, process_noise, num_samples): Генерирует массив случайных чисел с гауссовским распределением со средним значением 0 и стандартным отклонением process_noise.
filtered_position = [] и filtered_velocity = []: Инициализирует пустые списки для хранения результатов фильтрации.
for i in range(num_samples):: Цикл, который проходит по всем временным шагам.
Предсказание (Prediction):
x = np.dot(A, x): Предсказывает текущее состояние (x) на основе предыдущего состояния, используя матрицу перехода состояния A.
P = np.dot(np.dot(A, P), A.T) + Q: Предсказывает ковариационную матрицу ошибки P, используя матрицу перехода состояния A и ковариационную матрицу шума процесса Q.
Измерение:
z = np.array([[measured_position[i]]]): Получает зашумленное измерение положения (z) в текущий момент времени.
Коррекция (Update):
y = z - np.dot(H, x): Вычисляет инновацию (разницу между измерением z и предсказанным измерением, полученным с помощью H и x).
S = np.dot(np.dot(H, P), H.T) + R: Вычисляет ковариацию инновации S.
K = np.dot(np.dot(P, H.T), np.linalg.inv(S)): Вычисляет коэффициент усиления Калмана K. Коэффициент K определяет, насколько сильно фильтр полагается на текущее измерение.
x = x + np.dot(K, y): Обновляет оценку состояния x на основе инновации y и коэффициента усиления Калмана K.
P = P - np.dot(np.dot(K, H), P): Обновляет ковариационную матрицу ошибки P.
Сохранение результатов:
filtered_position.append(x[0, 0]): Сохраняет оценку положения (первый элемент вектора x).
filtered_velocity.append(x[1, 0]): Сохраняет оценку скорости (второй элемент вектора x).
plt.figure(figsize=(12, 6)): Создает новое окно для графиков размером 12x6 дюймов.
plt.subplot(2, 1, 1) и plt.subplot(2, 1, 2): Создают два подграфика: один для положения, другой для скорости. (2, 1, 1) создает сетку из 2 строк и 1 столбца и выбирает первый график, (2, 1, 2) - второй.
plt.plot(true_position, label='True Position'): Построение графика истинного положения.
plt.plot(measured_position, label='Measured Position'): Построение графика измеренного положения.
plt.plot(filtered_position, label='Filtered Position'): Построение графика отфильтрованного положения.
plt.plot(true_velocity, label='True Velocity'): Построение графика истинной скорости.
plt.plot(measured_velocity, label='Measured Velocity'): Построение графика измеренной скорости.
plt.plot(filtered_velocity, label='Filtered Velocity'): Построение графика отфильтрованной скорости.
plt.legend(): Добавляет легенду к графику.
plt.title('Position') и plt.title('Velocity'): Задает заголовок для каждого подграфика.
plt.tight_layout(): Автоматически корректирует расположение подграфиков, чтобы они не перекрывались.
plt.show(): Выводит все построенные графики на экран.

